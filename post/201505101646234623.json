{"id":"201505101646234623","content":"Consequently, if you actually want to test whether two strings have the same value you should use .equals().\r\n\r\nThere are however a few situations where you can guarantee that two strings with the same value will be represented by the same object because of String interning. Those cases are specified by the Java Language Specification.\r\n\r\n== is for testing whether two strings are the same object.\r\n\r\n\/\/ These two have the same value\r\nnew String(\"test\").equals(\"test\") \/\/ --> true \r\n\r\n\/\/ ... but they are not the same object\r\nnew String(\"test\") == \"test\" \/\/ --> false \r\n\r\n\/\/ ... neither are these\r\nnew String(\"test\") == new String(\"test\") \/\/ --> false \r\n\r\n\/\/ ... but these are because literals are interned by \r\n\/\/ the compiler and thus refer to the same object\r\n\"test\" == \"test\" \/\/ --> true \r\n\r\n\/\/ concatenation of string literals happens at compile time,\r\n\/\/ also resulting in the same object\r\n\"test\" == \"te\" + \"st\" \/\/ --> true\r\n\r\n\/\/ but .substring() is invoked at runtime, generating distinct objects\r\n\"test\" == \"!test\".substring(1) \/\/ --> false\r\n\r\n\/\/ interned strings can also be recalled by calling .intern()\r\n\"test\" == \"!test\".substring(1).intern() \/\/ --> true","author":"stack over","title":"tests for value equality.","toapprove":[],"comments":[]}